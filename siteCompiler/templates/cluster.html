{% extends "base.html" %}
{% block title %}Cluster {{ cluster_id }}: {{ cluster_name }}{% endblock %}

{% block head %}
<script src="{{ root }}assets/graphology.umd.min.js"></script>
<script src="{{ root }}assets/sigma.min.js"></script>
<script src="{{ root }}data/cluster_{{ cluster_id }}.js"></script>
<script src="{{ root }}data/show_vocab.js"></script>
<script src="{{ root }}data/pathfinding.js"></script>
{% endblock %}

{% block content %}
<div id="cluster-header">
  <a href="{{ root }}index.html" class="back-btn">&larr; All Clusters</a>
  <h1>Cluster {{ cluster_id }}: {{ cluster_name }}</h1>
  <span class="cluster-stats">{{ node_count }} shows &middot; {{ edge_count }} edges</span>
</div>
<div id="graph-wrapper">
  <div id="sigma-container"></div>
  <div id="legend">
    <div class="legend-title">Centrality (vocabulary overlap)</div>
    <div class="legend-bar"></div>
    <div class="legend-labels">
      <span>Low centrality (harder)</span>
      <span>High centrality (easier)</span>
    </div>
  </div>
</div>
<div id="detail-panel" class="detail-panel" style="display:none;">
  <button id="detail-close" class="detail-close">&times;</button>
  <h2 id="detail-title"></h2>
  <div id="detail-meta" class="detail-meta"></div>
  <button id="why-btn" class="why-btn" style="display:none">Why is this here?</button>
  <h3>Neighbors (by similarity)</h3>
  <ul id="detail-neighbors" class="neighbor-list"></ul>
</div>
{% endblock %}

{% block scripts %}
<script>
(function() {
  var data = CLUSTER_DATA;
  var Graph = graphology.Graph;
  var graph = new Graph();

  var nodeMap = {};
  data.nodes.forEach(function(n) {
    nodeMap[n.id] = n;
    graph.addNode(n.id, {
      x: n.x, y: n.y,
      size: n.size,
      color: n.color,
      label: n.label,
      category: n.category,
      episodes: n.episodes,
      centrality: n.centrality,
      globalCentrality: n.globalCentrality,
      tokens: n.tokens,
      forceLabel: false
    });
  });

  data.edges.forEach(function(e) {
    if (!graph.hasEdge(e.source, e.target) && !graph.hasEdge(e.target, e.source)) {
      graph.addEdge(e.source, e.target, {
        weight: e.weight,
        size: 0.5,
        color: '{{ theme.edge_default }}'
      });
    }
  });

  var container = document.getElementById('sigma-container');
  var detailPanel = document.getElementById('detail-panel');
  var detailTitle = document.getElementById('detail-title');
  var detailMeta = document.getElementById('detail-meta');
  var detailNeighbors = document.getElementById('detail-neighbors');
  var detailClose = document.getElementById('detail-close');
  var whyBtn = document.getElementById('why-btn');

  var selectedNode = null;
  var hoveredNode = null;

  var renderer = new Sigma(graph, container, {
    renderLabels: true,
    labelColor: { color: '#333' },
    labelFont: 'sans-serif',
    labelSize: 11,
    labelRenderedSizeThreshold: 8,
    defaultEdgeColor: '{{ theme.edge_default }}',
    defaultEdgeType: 'line',
    stagePadding: 30,
    allowInvalidContainer: true
  });

  function getNeighborsSorted(nodeId) {
    var neighbors = [];
    graph.forEachEdge(nodeId, function(edge, attrs, src, tgt) {
      var other = src === nodeId ? tgt : src;
      neighbors.push({ id: other, weight: attrs.weight || 0 });
    });
    neighbors.sort(function(a, b) { return b.weight - a.weight; });
    return neighbors;
  }

  function showDetail(nodeId) {
    var attrs = graph.getNodeAttributes(nodeId);
    selectedNode = nodeId;
    detailTitle.textContent = attrs.label;
    detailMeta.innerHTML =
      '<div><strong>Category:</strong> ' + attrs.category + '</div>' +
      '<div><strong>Episodes:</strong> ' + attrs.episodes + '</div>' +
      '<div><strong>Total tokens:</strong> ' + (attrs.tokens || 0).toLocaleString() + '</div>' +
      '<div><strong>Centrality (in-cluster):</strong> ' + ((attrs.centrality || 0) * 100).toFixed(0) + '%</div>' +
      '<div><strong>Centrality (global):</strong> ' + ((attrs.globalCentrality || 0) * 100).toFixed(0) + '%</div>';

    // "Why here?" button
    if (typeof SHOW_VOCAB !== 'undefined' && SHOW_VOCAB.shows && SHOW_VOCAB.shows[nodeId]) {
      whyBtn.style.display = 'block';
      whyBtn.onclick = function() {
        var nbList = getNeighborsSorted(nodeId).slice(0, 5).map(function(nb) {
          var na = graph.getNodeAttributes(nb.id);
          return { id: nb.id, label: na.label, weight: nb.weight };
        });
        showWhyPopup(nodeId, attrs.label, data.clusterId, nbList);
      };
    } else {
      whyBtn.style.display = 'none';
    }

    // Build neighbor list from full graph adjacency (includes cross-cluster edges)
    var allNeighbors = [];
    if (typeof PATHFINDING_DATA !== 'undefined' && PATHFINDING_DATA.adj[nodeId]) {
      PATHFINDING_DATA.adj[nodeId].forEach(function(pair) {
        var nbId = String(pair[0]);
        var weight = pair[1];
        var nbNode = PATHFINDING_DATA.nodes[nbId];
        if (nbNode) {
          allNeighbors.push({
            id: nbId, label: nbNode.t, weight: weight,
            cluster: nbNode.c, local: graph.hasNode(nbId)
          });
        }
      });
    } else {
      // Fallback to cluster-only edges if pathfinding data unavailable
      getNeighborsSorted(nodeId).forEach(function(nb) {
        var nbAttrs = graph.getNodeAttributes(nb.id);
        allNeighbors.push({
          id: nb.id, label: nbAttrs.label, weight: nb.weight,
          cluster: data.clusterId, local: true
        });
      });
    }
    detailNeighbors.innerHTML = '';
    allNeighbors.slice(0, 30).forEach(function(nb) {
      var li = document.createElement('li');
      var a = document.createElement('a');
      a.textContent = nb.label;
      if (nb.local) {
        a.href = '#';
        a.onclick = function(e) {
          e.preventDefault();
          selectAndFocus(nb.id);
        };
      } else {
        a.href = '{{ root }}cluster/' + nb.cluster + '.html#show=' + nb.id;
      }
      li.appendChild(a);
      if (!nb.local) {
        var badge = document.createElement('span');
        badge.className = 'cluster-badge';
        badge.textContent = 'C' + nb.cluster;
        li.appendChild(badge);
      }
      var span = document.createElement('span');
      span.className = 'nb-weight';
      span.textContent = (nb.weight * 100).toFixed(1) + '%';
      li.appendChild(span);
      detailNeighbors.appendChild(li);
    });

    detailPanel.style.display = 'block';
    renderer.refresh();
  }

  function selectAndFocus(nodeId) {
    selectedNode = nodeId;
    showDetail(nodeId);
    var attrs = graph.getNodeAttributes(nodeId);
    var camera = renderer.getCamera();
    camera.animate({ x: attrs.x, y: attrs.y, ratio: 0.15 }, { duration: 400 });
  }

  detailClose.addEventListener('click', function() {
    selectedNode = null;
    detailPanel.style.display = 'none';
    renderer.refresh();
  });

  renderer.on('clickNode', function(e) {
    selectAndFocus(e.node);
  });

  renderer.on('clickStage', function() {
    selectedNode = null;
    detailPanel.style.display = 'none';
    renderer.refresh();
  });

  renderer.on('enterNode', function(e) {
    hoveredNode = e.node;
    container.style.cursor = 'pointer';
    renderer.refresh();
  });

  renderer.on('leaveNode', function() {
    hoveredNode = null;
    container.style.cursor = 'default';
    renderer.refresh();
  });

  var activeNode = function() { return hoveredNode || selectedNode; };

  renderer.setSetting('nodeReducer', function(node, attrs) {
    var res = Object.assign({}, attrs);
    var an = activeNode();
    if (an) {
      if (node === an) {
        res.highlighted = true;
        res.zIndex = 2;
      } else if (graph.hasEdge(an, node) || graph.hasEdge(node, an)) {
        res.zIndex = 1;
      } else {
        res.color = 'rgba(200,200,200,0.3)';
        res.label = '';
      }
    }
    return res;
  });

  renderer.setSetting('edgeReducer', function(edge, attrs) {
    var res = Object.assign({}, attrs);
    var an = activeNode();
    if (an) {
      var src = graph.source(edge);
      var tgt = graph.target(edge);
      if (src === an || tgt === an) {
        res.color = '{{ theme.edge_focus }}';
        res.size = 1.5;
        res.hidden = false;
      } else {
        res.hidden = true;
      }
    }
    return res;
  });

  // Handle #show=ID hash for deep-linking from search
  function checkHash() {
    var hash = window.location.hash;
    var match = hash.match(/show=(\d+)/);
    if (match) {
      var id = match[1];
      if (graph.hasNode(id)) {
        setTimeout(function() { selectAndFocus(id); }, 300);
      }
    }
  }
  checkHash();
  window.addEventListener('hashchange', checkHash);
})();
</script>
{% endblock %}
